--
layout: post
title: HellHound framework
date: 2017-10-10 13:44
categories: Clojure HellHound
tags: Blog
author: lxsameer
description: HellHound
---

### TL;DR
> **HellHound** is an open source set of libraries to create simple and elegant programs and data pipelines based on streams.

I'm pretty sure that as a programmer, you already know how tough is to design and implement a software. It might seems easy at
first, but as the program grows it gets harder and harder. Or the first version of the software might be very well written but
as time passes by and developers come and go, that cute program will turn into a giant beast with 42 eyes 600 hands and not leg
to move. Specially if business values rules over the technical values in a team. All of us had the same experience sometime in
our career.


I'm pretty sure that as a programmer, you already know how tough is to design and implement a software. There are lots of details
to think about before hand. Beside the technical design there are other details involved in the process which are not just about
the software itself. For instance how would be the development process, How should the team handle the software maintainance and etc.

There are lots of books around software and system design that demonstrate the importance of this subject. These books had been
wrote to address a certain problem which people have. How to write a well designed program ?



I struggled with the same problem a lot during my career. After all these years I learned several important facts about good designes
and people behind those.

## There's no ultimate design
In all my career I saw to many people who had an ultimate design for every single problem they tried to solve and for every software they wrote.
A solution which evolved in time and became what they worship. When they want to come up with a new solution for a new problem, their unconscious
mind starts to use the same old solution.

It is safe to say that a single design pattern won't work for every problem we're trying to solve. Because no two problems are the same. Each problem
has a unique charactristic. Two problem might be really similar to each other but at least they would have one difference. The Time. We might face
a problem which we solved in the past and since we already solved that, it would make sense to take the same approach and design to solve that again.



## It's a trade off

## Right tools

## Simplicity is the most important factor
